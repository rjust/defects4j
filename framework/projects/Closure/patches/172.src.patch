diff --git a/src/com/google/javascript/jscomp/JsAst.java b/src/com/google/javascript/jscomp/JsAst.java
index ff71d944..2ada6d2a 100644
--- a/src/com/google/javascript/jscomp/JsAst.java
+++ b/src/com/google/javascript/jscomp/JsAst.java
@@ -79,8 +79,8 @@ public class JsAst implements SourceAst {
   }
 
   private void parse(AbstractCompiler compiler) {
-    int startErrorCount = compiler.getErrorManager().getErrorCount();
     try {
+      logger_.fine("Parsing: " + sourceFile.getName());
       ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),
           compiler.getParserConfig(),
           compiler.getDefaultErrorReporter(),
@@ -92,12 +92,7 @@ public class JsAst implements SourceAst {
           JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));
     }
 
-
-    if (root == null ||
-        // Most passes try to report as many errors as possible,
-        // so there may already be errors. We only care if there were
-        // errors in the code we just parsed.
-        (compiler.getErrorManager().getErrorCount() > startErrorCount && !compiler.isIdeMode())) {
+    if (root == null || compiler.hasHaltingErrors()) {
       // There was a parse error or IOException, so use a dummy block.
       root = IR.script();
     } else {
diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
index 4facea30..c4f7f8da 100644
--- a/src/com/google/javascript/jscomp/NodeUtil.java
+++ b/src/com/google/javascript/jscomp/NodeUtil.java
@@ -2364,11 +2364,8 @@ public final class NodeUtil {
     if (nameNode.isName()) {
       result = IR.var(nameNode, value);
       result.setJSDocInfo(info);
-    } else if (value != null) {
-      result = IR.exprResult(IR.assign(nameNode, value));
-      result.getFirstChild().setJSDocInfo(info);
     } else {
-      result = IR.exprResult(nameNode);
+      result = IR.exprResult(IR.assign(nameNode, value));
       result.getFirstChild().setJSDocInfo(info);
     }
     return result;
diff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java
index 3a771c95..7108f27f 100644
--- a/src/com/google/javascript/jscomp/ScopedAliases.java
+++ b/src/com/google/javascript/jscomp/ScopedAliases.java
@@ -353,8 +353,8 @@ class ScopedAliases implements HotSwapCompilerPass {
       for (Var v : scope.getVarIterable()) {
         Node n = v.getNode();
         Node parent = n.getParent();
-        boolean isVar = parent.isVar();
-        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
+        boolean isVarAssign = parent.isVar() && n.hasChildren();
+        if (isVarAssign && n.getFirstChild().isQualifiedName()) {
           recordAlias(v);
         } else if (v.isBleedingFunction()) {
           // Bleeding functions already get a BAD_PARAMETERS error, so just
@@ -362,10 +362,8 @@ class ScopedAliases implements HotSwapCompilerPass {
         } else if (parent.getType() == Token.LP) {
           // Parameters of the scope function also get a BAD_PARAMETERS
           // error.
-        } else if (isVar) {
-          Node value = n.hasChildren() ?
-              v.getInitialValue().detachFromParent() :
-              null;
+        } else if (isVarAssign) {
+          Node value = v.getInitialValue().detachFromParent();
           String name = n.getString();
           int nameCount = scopedAliasNames.count(name);
           scopedAliasNames.add(name);
@@ -376,17 +374,15 @@ class ScopedAliases implements HotSwapCompilerPass {
 
           // Add $jscomp.scope.name = EXPR;
           // Make sure we copy over all the jsdoc and debug info.
-          if (value != null || v.getJSDocInfo() != null) {
-            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
-                compiler.getCodingConvention(),
-                globalName,
-                value,
-                v.getJSDocInfo())
-                .useSourceInfoIfMissingFromForTree(n);
-            NodeUtil.setDebugInformation(
-                newDecl.getFirstChild().getFirstChild(), n, name);
-            parent.getParent().addChildBefore(newDecl, parent);
-          }
+          Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
+              compiler.getCodingConvention(),
+              globalName,
+              value,
+              v.getJSDocInfo())
+              .useSourceInfoIfMissingFromForTree(n);
+          NodeUtil.setDebugInformation(
+              newDecl.getFirstChild().getFirstChild(), n, name);
+          parent.getParent().addChildBefore(newDecl, parent);
 
           // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;"
           v.getNameNode().addChildToFront(
