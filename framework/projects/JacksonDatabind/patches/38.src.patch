diff --git a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
index c0e79c8c0..3f3289e72 100644
--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
@@ -25,24 +25,20 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
     /**
      * State in which iterator is closed
      */
-    protected final static int STATE_CLOSED = 0;
     
     /**
      * State in which value read failed
      */
-    protected final static int STATE_NEED_RESYNC = 1;
     
     /**
      * State in which no recovery is needed, but "hasNextValue()" needs
      * to be called first
      */
-    protected final static int STATE_MAY_HAVE_VALUE = 2;
 
     /**
      * State in which "hasNextValue()" has been succesfully called
      * and deserializer can be called to fetch value
      */
-    protected final static int STATE_HAS_VALUE = 3;
 
     /*
     /**********************************************************
@@ -70,13 +66,12 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
      * as not <code>null</code> but set as <code>null</null> when
      * iterator is closed, to denote closing.
      */
-    protected final JsonParser _parser;
+    protected JsonParser _parser;
 
     /**
      * Context to resynchronize to, in case an exception is encountered
      * but caller wants to try to read more elements.
      */
-    protected final JsonStreamContext _seqContext;
     
     /**
      * If not null, "value to update" instead of creating a new instance
@@ -100,7 +95,7 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
     /**
      * State of the iterator
      */
-    protected int _state;
+    protected boolean _hasNextChecked;
 
     /*
     /**********************************************************
@@ -115,12 +110,12 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
      *   closed by iterator.
      */
     @SuppressWarnings("unchecked")
-    protected MappingIterator(JavaType type, JsonParser p, DeserializationContext ctxt,
+    protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt,
             JsonDeserializer<?> deser,
             boolean managedParser, Object valueToUpdate)
     {
         _type = type;
-        _parser = p;
+        _parser = jp;
         _context = ctxt;
         _deserializer = (JsonDeserializer<T>) deser;
         _closeParser = managedParser;
@@ -140,25 +135,12 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
          * and if not, caller needs to hand us JsonParser instead, pointing to
          * the first token of the first element.
          */
-        if (p == null) { // can this occur?
-            _seqContext = null;
-            _state = STATE_CLOSED;
-        } else {
-            JsonStreamContext sctxt = p.getParsingContext();
-            if (managedParser && p.isExpectedStartArrayToken()) {
+        if (managedParser && (jp != null) && jp.isExpectedStartArrayToken()) {
                 // If pointing to START_ARRAY, context should be that ARRAY
-                p.clearCurrentToken();
-            } else {
+            jp.clearCurrentToken();
                 // regardless, recovery context should be whatever context we have now,
                 // with sole exception of pointing to a start marker, in which case it's
                 // the parent
-                JsonToken t = p.getCurrentToken();
-                if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) {
-                    sctxt = sctxt.getParent();
-                }
-            }
-            _seqContext = sctxt;
-            _state = STATE_MAY_HAVE_VALUE;
         }
     }
 
@@ -204,11 +186,8 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
     
     @Override
     public void close() throws IOException {
-        if (_state != STATE_CLOSED) {
-            _state = STATE_CLOSED;
             if (_parser != null) {
                 _parser.close();
-            }
         }
     }
 
@@ -228,28 +207,24 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
      */
     public boolean hasNextValue() throws IOException
     {
-        switch (_state) {
-        case STATE_CLOSED:
+        if (_parser == null) {
             return false;
-        case STATE_NEED_RESYNC:
-            _resync();
-            // fall-through
-        case STATE_MAY_HAVE_VALUE:
+        }
+        if (!_hasNextChecked) {
             JsonToken t = _parser.getCurrentToken();
+            _hasNextChecked = true;
             if (t == null) { // un-initialized or cleared; find next
                 t = _parser.nextToken();
                 // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token).
                 if (t == null || t == JsonToken.END_ARRAY) {
-                    _state = STATE_CLOSED;
-                    if (_closeParser && (_parser != null)) {
-                        _parser.close();
+                    JsonParser jp = _parser;
+                    _parser = null;
+                    if (_closeParser) {
+                        jp.close();
                     }
                     return false;
                 }
             }
-            _state = STATE_HAS_VALUE;
-            return true;
-        case STATE_HAS_VALUE:
             // fall through
         }
         return true;
@@ -257,32 +232,24 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
 
     public T nextValue() throws IOException
     {
-        switch (_state) {
-        case STATE_CLOSED:
-            return _throwNoSuchElement();
-        case STATE_NEED_RESYNC: // fall-through, will do re-sync
-        case STATE_MAY_HAVE_VALUE:
+        if (!_hasNextChecked) {
             if (!hasNextValue()) {
                 return _throwNoSuchElement();
             }
-            break;
-        case STATE_HAS_VALUE:
-            break;
         }
+        if (_parser == null) {
+            return _throwNoSuchElement();
+        }
+        _hasNextChecked = false;
 
-        int nextState = STATE_NEED_RESYNC;
         try {
-            T value;
             if (_updatedValue == null) {
-                value = _deserializer.deserialize(_parser, _context);
+                return _deserializer.deserialize(_parser, _context);
             } else{
                 _deserializer.deserialize(_parser, _context, _updatedValue);
-                value = _updatedValue;
+                return _updatedValue;
             }
-            nextState = STATE_MAY_HAVE_VALUE;
-            return value;
         } finally {
-            _state = nextState;
             /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no
              *   matter what, to avoid infinite loop for certain failure cases.
              *   For 2.6 need to improve further.
@@ -379,28 +346,7 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
     /**********************************************************
      */
 
-    protected void _resync() throws IOException
-    {
-        final JsonParser p = _parser;
-        // First, a quick check to see if we might have been lucky and no re-sync needed
-        if (p.getParsingContext() == _seqContext) {
-            return;
-        }
 
-        while (true) {
-            JsonToken t = p.nextToken();
-            if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) {
-                if (p.getParsingContext() == _seqContext) {
-                    p.clearCurrentToken();
-                    return;
-                }
-            } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) {
-                p.skipChildren();
-            } else if (t == null) {
-                return;
-            }
-        }
-    }
 
     protected <R> R _throwNoSuchElement() {
         throw new NoSuchElementException();
