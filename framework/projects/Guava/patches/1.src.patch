diff --git a/google/common/collect/MinMaxPriorityQueue.java b/google/common/collect/MinMaxPriorityQueue.java
index a50bf25..c8dcf60 100644
--- a/google/common/collect/MinMaxPriorityQueue.java
+++ b/google/common/collect/MinMaxPriorityQueue.java
@@ -418,14 +418,7 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
       return null;
     }
     E actualLastElement = elementData(size);
-    int lastElementAt = heapForIndex(size).swapWithConceptuallyLastElement(actualLastElement);
-    if (lastElementAt == index) {
-      // 'actualLastElement' is now at 'lastElementAt', and the element that was at 'lastElementAt'
-      // is now at the end of queue. If that's the element we wanted to remove in the first place,
-      // don't try to (incorrectly) trickle it. Instead, just delete it and we're done.
-      queue[size] = null;
-      return null;
-    }
+    int lastElementAt = heapForIndex(size).getCorrectLastElement(actualLastElement);
     E toTrickle = elementData(size);
     queue[size] = null;
     MoveDesc<E> changes = fillHole(index, toTrickle);
@@ -676,8 +669,7 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
     }
 
     /**
-     * Swap {@code actualLastElement} with the conceptually correct last element of the heap.
-     * Returns the index that {@code actualLastElement} now resides in.
+     * Returns the conceptually correct last element of the heap.
      *
      * <p>Since the last element of the array is actually in the
      * middle of the sorted structure, a childless uncle node could be
@@ -685,7 +677,7 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
      * becomes the new parent of the uncle. In that case, we first
      * switch the last element with its uncle, before returning.
      */
-    int swapWithConceptuallyLastElement(E actualLastElement) {
+    int getCorrectLastElement(E actualLastElement) {
       int parentIndex = getParentIndex(size);
       if (parentIndex != 0) {
         int grandparentIndex = getParentIndex(parentIndex);
@@ -825,9 +817,7 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
             forgetMeNot = new ArrayDeque<E>();
             skipMe = new ArrayList<E>(3);
           }
-          if (!containsExact(skipMe, moved.toTrickle)) {
-            forgetMeNot.add(moved.toTrickle);
-          }
+          forgetMeNot.add(moved.toTrickle);
           skipMe.add(moved.replaced);
         }
         cursor--;
